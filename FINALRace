from contextlib import nullcontext
from os import times

import pygame
import asyncio
import math
import random
from pygame.locals import *
import os
import sysconfig
import atexit

from win32verstamp import nullterm, null_byte

dll_path = sysconfig.get_config_var("BINDIR")
os.add_dll_directory(dll_path)
# List of assets (images, sounds, and other files)

assets = [
    "road.png",
    "car1.png", "car2.png", "car3.png", "car4.png", "car5.png", "car6.png",
    "snowtree.png", "tree.png", "cactus.png", "facingcar.png",
    "68. Rainbow Road.mp3", "Magical Sound Shower.mp3", "28. Coconut Mall.mp3",
    "04 A little good - Lightning.mp3", "1-109. Bowser's Castle_.mp3",
    "GT2_13201_2.wav", "brake-101soundboards.mp3", "collapse-101soundboards.mp3",
    "icon.ico"  # Include your icon file
]

# Global variables and settings
global time, delta, player_car_rect, collision_occurred, current_environment_index, b, r, r2, g, terrain_mode
time = True
delta = 0
SCREENHEIGHT = 240
SCREENWIDTH = 320
screen_size = (SCREENWIDTH, SCREENHEIGHT)
highscore = 0

BLACK = pygame.Color ('black')
WHITE = pygame.Color ('white')
LIGHT_GRAY = pygame.Color ('lightgray')

# Music and car configurations
songs = [
    "68. Rainbow Road.mp3", "Magical Sound Shower.mp3",
    "28. Coconut Mall.mp3", "04 A little good - Lightning.mp3",
    "1-109. Bowser's Castle_.mp3"
]
cars_images = ["car1.png", "car2.png", "car3.png", "car4.png", "car5.png", "car6.png"]
# Define the environment colors (Grass, Desert, Snow)
environments = [
    (lambda draw_distance, z, x: (
        max(0, min(255, int(34 - draw_distance / 3))),  # Grass green
        max(0, min(255, int(139 - draw_distance))),
        max(0, min(255, int(34 - z / 20 + 30 * math.sin(x))))
    )),
    (lambda draw_distance, z, x: (
        max(0, min(255, int(222 - draw_distance / 3))),  # Desert tan
        max(0, min(255, int(200 - draw_distance / 2))),
        max(0, min(255, int(135 - z / 20 + 30 * math.sin(x))))
    )),
    (lambda draw_distance, z, x: (
        max (0, min (255, int (280 - z / 20 + 30 * math.sin (x)))),  # Snow white
        max (0, min (255, int (280 - z / 20 + 30 * math.sin (x)))),
        max (0, min (255, int (300 - z / 20 + 30 * math.sin (x))))  # Cooler hue
    )),
]
current_environment_index = 0
current_song_index = 0
current_car_index = 0
music_playing = False
music_screen = False
car_screen = False
buttons_visible = False
collision_occurred = False
running = True
start = False

# Initialize pygame
pygame.init ()
pygame.mixer.init ()

# Load car images and tree sprite
car_sprite = pygame.image.load ("car1.png")
car_sprite2 = pygame.image.load ("facingcar.png")
road_texture = pygame.image.load ("road.png")
car_sprite2_rect = car_sprite2.get_rect ()
car_sprite2_mask = pygame.mask.from_surface (car_sprite2)
tree_sprite = pygame.image.load ("tree.png")





def play_music(song_index):
    """Play the selected song."""
    pygame.mixer.music.load(songs[current_song_index])
    pygame.mixer.music.set_volume(0.5)  # Adjust volume for balance
    pygame.mixer.music.play(-1)


class Tree:
    def __init__ (self, distance):
        self.x = distance + random.randint (10, 20) + 0.5
        self.y = random.randint (500, 1500) * random.choice ([-1, 1])


def calc_y (x):
    return 200 * math.sin (x / 15) + 250 * math.sin (x / 7)

import math
import pygame

# Initial terrain parameters
b = 80.0  # Start values for "normal" as float
r = 140.0
r2 = 17.0
g = 8.0
terrain_mode = "normal"  # Starting terrain mode
transition_speed = 0.2  # Global transition speed

# Global variables
start_time = None
start = False
transition_duration = 2000  # 2 seconds for transition

def start_button_pressed():
    global start_time, start
    if not start:
        start = True  # Start the transition when the button is pressed
        start_time = pygame.time.get_ticks()  # Record the time when start is pressed


def calc_z(x):
    global b, r, r2, g, c_base, terrain_mode, start_time, transition_duration

    # Initialize c_base if it doesn't exist
    if "c_base" not in globals():
        c_base = 0

    # Set the initial terrain if no transition has started
    if start_time is None:
        c_base = -r * math.sin(x / g)

    # Calculate time elapsed
    current_time = pygame.time.get_ticks()
    time_elapsed = current_time - start_time
    if time_elapsed > transition_duration:
        time_elapsed = transition_duration

    # Transition factor (0 to 1)
    transition_factor = time_elapsed / transition_duration

    # Terrain mode settings and targets
    terrain_targets = {
        "normal": (120.0, 5.0, 17.0, 30.0, -50.0, "uphill"),
        "uphill": (220.0, 200.0, 17.0, 5.0, -120.0, "flat"),
        "steep": (80.0, 140.0, 17.0, 8.0, -80.0, "flat"),
        "flat": (10.0, 50.0, 17.0, 50.0, -0.1, "downhill"),
        "downhill": (-70.0, 100.0, 20.0, 60.0, 140.0, "normal")
    }

    if terrain_mode in terrain_targets:
        target_b, target_r, target_r2, target_g, target_c_base, next_mode = terrain_targets[terrain_mode]
    else:
        next_mode = "normal"

    # Smooth transition for c_base
    c_base += (target_c_base - c_base) * (transition_factor * 0.000001)  # Adjusted for smoother transition
    c = max(-300, min(300, c_base))  # Clamp c to be between -300 and 300

    # Calculate z based on the transition
    z = 200 + b * math.sin(x / r2) + c

    # Gradual transition for other terrain parameters
    if abs(b - target_b) > 1:
        b += (target_b - b) * (transition_factor * 0.000003)  # Adjust transition speed for b
        return z
    if abs(r2 - target_r2) > 1:
        r2 += (target_r2 - r2) * (transition_factor * 0.000005)
        return z
    if abs(r - target_r) > 1:
        r += (target_r - r) * (transition_factor * 0.000005)
        return z
    if abs(g - target_g) > 1:
        g += (target_g - g) * (transition_factor * 0.005)
        return z

    # If all parameters are close to their targets, switch terrain mode
    terrain_mode = next_mode
    print(f"Terrain mode changed to {terrain_mode}")
    start_time = pygame.time.get_ticks()  # Restart transition timer for smooth cycling
    return z

def render_element(screen, sprite, width, height, scale, x, car, y, z_buffer):
    # Calculate z once and apply smoothing
    z_value = calc_z(x) - car.z
    vertical = int(60 + 160 * scale + z_value * scale)

    # Calculate y based on x, no changes to the y calculation
    adjusted_y = calc_y(x) - y

    # Calculate horizontal position based on car's angle
    horizontal = int(160 - (65 - adjusted_y) * scale) + car.angle * (vertical - 150)

    # Check if vertical is in the valid range and z-buffer for that pixel is clear
    if 1 <= vertical < 180 and z_buffer[vertical - 1] > 1 / scale - 10:
        # Scale the sprite based on width and height, then blit to screen
        scaled_sprite = pygame.transform.scale(sprite, (width, height))
        screen.blit(scaled_sprite, (horizontal, 60 + vertical - height + 1))

        # Update z_buffer with the calculated z_value at the specific vertical position
        z_buffer[vertical - 1] = max(z_buffer[vertical - 1], z_value)

class Car:
    def __init__(self, distance):
        self.x = distance + random.randint(90, 110)


class Player:
    def __init__(self):
        self.angletwo = 0
        self.angleone = 0
        self.x = 0
        self.y = 300
        self.z = 0
        self.angle = 0
        self.velocity = 0
        self.acceleration = 1  # Constant acceleration for auto-forward movement
        self.left_pressed_time = 0  # Time spent pressing left
        self.right_pressed_time = 0  # Time spent pressing right

    def controls(self, delta):
        pressed_keys = pygame.key.get_pressed()

        # Auto-accelerate
        self.velocity += self.acceleration * delta

        # Track left/right input time
        if pressed_keys[pygame.K_a] or pressed_keys[pygame.K_LEFT]:
            self.left_pressed_time += delta
            self.right_pressed_time = 0  # Reset right press time
        elif pressed_keys[pygame.K_d] or pressed_keys[pygame.K_RIGHT]:
            self.right_pressed_time += delta
            self.left_pressed_time = 0  # Reset left press time
        else:
            # Reset both times if no directional input
            self.left_pressed_time = 0
            self.right_pressed_time = 0

        # End game if only going left or right for 10 seconds
        if self.left_pressed_time >= 10 or self.right_pressed_time >= 10:
            print("Game Over: You drove off into the grass for too long!")
            pygame.quit()
            exit()

        # Steering
        if pressed_keys[pygame.K_a] or pressed_keys[pygame.K_LEFT]:
            self.angle -= (delta * self.velocity / 10) % 1
        elif pressed_keys[pygame.K_d] or pressed_keys[pygame.K_RIGHT]:
            self.angle += (delta * self.velocity / 10) % 1

        # Clamp velocity and angle values
        self.velocity = max(-30, min(self.velocity, 24))
        self.angle = max(-0.8, min(0.8, self.angle))

        # Update position
        self.x += self.velocity * delta * math.cos(self.angle)
        self.y += self.velocity * math.sin(self.angle) * delta * 100

async def main_menu():
    global start, time, delta, total_time, music_playing, current_song_index, current_car_index, music_screen, car_screen, buttons_visible, car_sprite
    screen = pygame.display.set_mode(screen_size, pygame.SCALED)
    pygame.display.set_caption("Don't Crash!!!")

    font = pygame.font.Font(None, 36)
    small_font = pygame.font.Font(None, 24)

    # Buttons' Rectangles
    start_button = pygame.Rect(SCREENWIDTH / 2 - 60, 80, 120, 50)
    music_button = pygame.Rect(SCREENWIDTH / 2 - 60, 140, 120, 50)
    cars_button = pygame.Rect(SCREENWIDTH / 2 - 60, 200, 120, 50)
    quit_button = pygame.Rect(SCREENWIDTH - 90, SCREENHEIGHT - 70, 120, 50)  # Positioned in the bottom-right corner

    while True:
        screen.fill(BLACK)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = event.pos
                if music_screen and buttons_visible:
                    if button1.collidepoint(mouse_pos):
                        current_song_index = (current_song_index - 1) % len(songs)
                        play_music(current_song_index)
                    elif button2.collidepoint(mouse_pos):
                        current_song_index = (current_song_index + 1) % len(songs)
                        play_music(current_song_index)
                    elif back_button.collidepoint(mouse_pos):
                        pygame.mixer.music.stop()
                        music_screen = False
                        buttons_visible = False
                elif car_screen and buttons_visible:
                    if button1.collidepoint(mouse_pos):
                        current_car_index = (current_car_index - 1) % len(cars_images)
                        car_sprite = pygame.image.load (cars_images[current_car_index])
                        car_sprite = pygame.image.load(cars_images[current_car_index])
                    elif button2.collidepoint(mouse_pos):
                        current_car_index = (current_car_index + 1) % len(cars_images)
                        car_sprite = pygame.image.load(cars_images[current_car_index])
                        car_sprite = pygame.image.load(cars_images[current_car_index])
                    elif back_button.collidepoint(mouse_pos):
                        car_screen = False
                        buttons_visible = False
                else:
                    if start_button.collidepoint(mouse_pos):
                        start_button_pressed ()
                        start = True
                        time = True
                        delta = 0
                        if not music_playing:
                            play_music(current_song_index)
                            music_playing = True
                        font = pygame.font.Font(None, 24)
                        instructions = [
                            "Press Down Arrow to slow down.",
                            "Press < for left and > for right."
                        ]
                        y_offset = 110
                        for instruction in instructions:
                            text = font.render(instruction, True, WHITE)
                            screen.blit(text, (10, y_offset))
                            y_offset += 30
                        pygame.display.update()
                        pygame.time.wait(1000)
                        return 'GAME'
                    elif music_button.collidepoint(mouse_pos):
                        music_screen = True
                        buttons_visible = True
                    elif cars_button.collidepoint(mouse_pos):
                        car_screen = True
                        buttons_visible = True
                    elif quit_button.collidepoint(mouse_pos):  # Check for quit button click
                        pygame.quit()

        if not music_screen and not car_screen:
            # Display Highscore
            highscore_hours = int(highscore // 3600)  # 1 hour = 3600 seconds
            highscore_minutes = int((highscore % 3600) // 60)  # 1 minute = 60 seconds
            highscore_seconds = int(highscore % 60)  # Remaining seconds
            highscore_milliseconds = int((highscore % 1) * 1000)

            # Render the highscore text
            highscore_text = small_font.render(
                f"Highscore: {highscore_hours:02}:{highscore_minutes:02}:{highscore_seconds:02}s.{highscore_milliseconds:03}s",
                True, WHITE)
            screen.blit(highscore_text, ((SCREENWIDTH / 2) - 80, 50))
            total_time = 0

            pygame.draw.rect(screen, LIGHT_GRAY, start_button)
            pygame.draw.rect(screen, LIGHT_GRAY, music_button)
            pygame.draw.rect(screen, LIGHT_GRAY, cars_button)
            pygame.draw.rect(screen, LIGHT_GRAY, quit_button)  # Draw the quit button
            screen.blit(font.render("Start", True, BLACK), (start_button.x + 15, start_button.y + 10))
            screen.blit(font.render("Music", True, BLACK), (music_button.x + 15, music_button.y + 10))
            screen.blit(font.render("Cars", True, BLACK), (cars_button.x + 15, cars_button.y + 10))
            screen.blit(font.render("Quit", True, BLACK),
                        (quit_button.x + 15, quit_button.y + 10))  # Render text on quit button

        elif music_screen:
            button1 = pygame.Rect(SCREENWIDTH / 2 - 120, 50, 120, 50)
            button2 = pygame.Rect(SCREENWIDTH / 2, 50, 120, 50)
            back_button = pygame.Rect(SCREENWIDTH / 2 - 60, 170, 120, 50)
            pygame.draw.rect(screen, LIGHT_GRAY, button1)
            pygame.draw.rect(screen, LIGHT_GRAY, button2)
            pygame.draw.rect(screen, LIGHT_GRAY, back_button)
            screen.blit(font.render("<--", True, BLACK), (button1.x + 30, button1.y + 10))
            screen.blit(font.render("-->", True, BLACK), (button2.x + 30, button2.y + 10))
            screen.blit(font.render("Back", True, BLACK), (back_button.x + 25, back_button.y + 10))

        elif car_screen:
            button1 = pygame.Rect(SCREENWIDTH / 2 - 120, 50, 120, 50)
            button2 = pygame.Rect(SCREENWIDTH / 2, 50, 120, 50)
            back_button = pygame.Rect(SCREENWIDTH / 2 - 60, 170, 120, 50)
            pygame.draw.rect(screen, LIGHT_GRAY, button1)
            pygame.draw.rect(screen, LIGHT_GRAY, button2)
            pygame.draw.rect(screen, LIGHT_GRAY, back_button)
            screen.blit(font.render("<--", True, BLACK), (button1.x + 30, button1.y + 10))
            screen.blit(font.render("-->", True, BLACK), (button2.x + 30, button2.y + 10))
            screen.blit (car_sprite, (135, 115))
            screen.blit(font.render("Back", True, BLACK), (back_button.x + 25, back_button.y + 10))

        pygame.display.update()

async def game_loop ():
    global highscore, b, r2, r, g, delta, time, total_time, terrain_mode,  collision_occurred, car_sprite, current_song_index, tree_sprite, current_environment_index, music_playing, cars, trees, enemy_position_offset, start
    screen = pygame.display.set_mode (screen_size, pygame.SCALED)
    pygame.display.set_caption ("Don't Crash!!!")

    clock = pygame.time.Clock ()


    car_sprite = pygame.image.load (cars_images[current_car_index])
    car_sprite2 = pygame.image.load ("facingcar.png").convert_alpha ()
    tree_sprite = pygame.image.load ("tree.png")

    realtime = False
    running = True
    total_time = 0
    collision_occurred = False
    collision_sound = pygame.mixer.Sound ("collapse-101soundboards.mp3")
    collision_sound.set_volume (0.2)

    def calc_vertical (x, car_z, scale, z_buffer, index):
        draw_distance = cars[index].x
        scale = 1 / draw_distance
        z = calc_z (draw_distance) - car_z
        vertical = int (60 + 160 * scale + z * scale)
        horizontal = int (160 - (65 - calc_y (draw_distance)) * scale) + car.angle * (vertical - 150)
        return horizontal, vertical

    # Maximum scale for the enemy car sprite
    MAX_ENEMY_CAR_SCALE = 0.5  # Adjust this value based on your needs

    car = Player()
    cars = [Car(-50), Car(-23), Car(7)]
    trees = [Tree(-67), Tree(-55), Tree(-43), Tree(-33), Tree(-25), Tree(-13), Tree(-3)]

    total_time = 0
    time = True
    # Main game loop
    while running & time:

        if clock == 0:
            clock = pygame.time.Clock ()

        delta = clock.tick() / 1000 + 0.00001
        total_time += delta
        car.controls(delta)

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if start:
                car.acceleration = 1

        # Alternate day/night every 45 seconds
        cycle_length = 45
        day_night_cycle = int (total_time // cycle_length) % 2  # 0 = day, 1 = night
        cycle_time = (total_time % cycle_length) / cycle_length  # 0.0 to 1.0 within current cycle

        if day_night_cycle == 0:
            # Day cycle fractions
            t = cycle_time  # 0.0 to 1.0 within the day

            # Define target colors for day
            day_start_color = (0, 0, 0)  # dark at sunrise
            sunrise_color = (255, 120, 50)  # sunrise orange
            midday_color = (100, 180, 220)  # blue sky
            pre_sunset_color = (255, 140, 60)  # pre-sunset orange
            day_end_color = (20, 20, 20)  # slightly darker black at sunset

            # Stage 1: Night -> sunrise (0.0 - 0.15)
            if t < 0.15:
                start_color = day_start_color
                end_color = sunrise_color
                local_t = t / 0.15
            # Stage 2: Sunrise -> midday blue (0.15 - 0.55)
            elif t < 0.55:
                start_color = sunrise_color
                end_color = midday_color
                local_t = (t - 0.15) / 0.4
            # Stage 3: Midday blue -> pre-sunset orange (0.55 - 0.8)
            elif t < 0.8:
                start_color = midday_color
                end_color = pre_sunset_color
                local_t = (t - 0.55) / 0.25
            # Stage 4: Pre-sunset -> end-of-day black (0.8 - 1.0)
            else:
                start_color = pre_sunset_color
                end_color = day_end_color
                local_t = (t - 0.8) / 0.2

            # Interpolate RGB values
            sky_red = int (start_color[0] + (end_color[0] - start_color[0]) * local_t)
            sky_green = int (start_color[1] + (end_color[1] - start_color[1]) * local_t)
            sky_blue = int (start_color[2] + (end_color[2] - start_color[2]) * local_t)

            screen.fill ((sky_red, sky_green, sky_blue))

            # Sun moves along an arc
            sun_x = int (-40 + 400 * t)
            sun_y = int (160 - math.sin (t * math.pi) * 100)
            pygame.draw.circle (screen, (255, 255, 100), (sun_x, sun_y), 30)

        else:
            # Night cycle fractions
            t = cycle_time

            # Night color targets based on day endpoints
            night_start_color = day_end_color  # start of night = end of day
            night_end_color = day_start_color  # end of night = start of day

            # Interpolate night sky
            sky_red = int (night_start_color[0] + (night_end_color[0] - night_start_color[0]) * t)
            sky_green = int (night_start_color[1] + (night_end_color[1] - night_start_color[1]) * t)
            sky_blue = int (night_start_color[2] + (night_end_color[2] - night_start_color[2]) * t)

            screen.fill ((sky_red, sky_green, sky_blue))

            # Stars
            star_offsets = [(-100, 20), (-40, 60), (30, 30), (100, 70)]
            for dx, dy in star_offsets:
                star_x = (160 + dx + int (car.x / 10)) % 320
                star_y = 30 + dy
                pygame.draw.circle (screen, (255, 255, 255), (star_x, star_y), 2)

            # Moon (slightly yellow)
            moon_x = int (-40 + 400 * t)
            moon_y = int (160 - math.sin (t * math.pi) * 100)
            pygame.draw.circle (screen, (255, 255, 180), (moon_x, moon_y), 25)

            # Convert total_time into hours, minutes, and seconds
        hours = int (total_time // 3600)  # 1 hour = 3600 seconds
        minutes = int ((total_time % 3600) // 60)  # 1 minute = 60 seconds
        seconds = int (total_time % 60)  # Remaining seconds
        milliseconds = int ((total_time % 1) * 1000)
        # Render the timer
        # Example simulation loop
        for i in range (100):  # Simulating 100 frames
            x_value = i * 10  # Example x-value progression
        font = pygame.font.Font (None, 36)
        timer_text = font.render (f"Time: {hours:02}:{minutes:02}:{seconds:02}.{milliseconds:03}", True, (255, 255, 255))
        screen.blit (timer_text, (10, 10))
        vertical, draw_distance = 180, 1
        car.z = calc_z(car.x)
        z_buffer = [999 for _ in range(180)]

        while draw_distance < 120:
            last_vertical = vertical
            while vertical >= last_vertical and draw_distance < 180:
                draw_distance += draw_distance / 150
                x = car.x + draw_distance
                scale = 1 / draw_distance
                z = calc_z(x) - car.z
                vertical = int(60 + 160 * scale + z * scale)

            if draw_distance < 115:
                z_buffer[int(vertical)] = draw_distance
                x = car.x + draw_distance
                road_slice = road_texture.subsurface((0, 10 * x % 170, 320, 1))
                # Determine the current environment based on elapsed time
                current_environment_index = int (total_time) // 30 % len (environments)
                current_color_func = environments[current_environment_index]
                # Calculate the color based on the current environment
                z = calc_z (x) - car.z
                color = current_color_func (draw_distance, z, x)
                pygame.draw.rect(screen, color, (0, 60 + vertical, 320, 1))
                scale = 1 / draw_distance
                render_element(screen, road_slice, 600 * scale, 1, scale, x, car, 70 + car.y, z_buffer)

        for index in reversed(range(len(trees) - 1)):
            if current_environment_index == 2:
                tree_sprite = pygame.image.load("snowtree.png")
            elif current_environment_index == 1:
                tree_sprite = pygame.image.load ("cactus.png")
            else:
                tree_sprite = pygame.image.load ("tree.png")
            tree_scale = max(0.0001, 1 / (trees[index].x - car.x))
            render_element(screen, tree_sprite, 200 * tree_scale, 300 * tree_scale, tree_scale, trees[index].x, car,
                           trees[index].y + car.y, z_buffer)

        if trees[0].x < car.x + 1:
            trees.pop(0)
            trees.append(Tree(trees[-1].x))

            # Replace `-45 + car.angle + 20` with an improved positioning formula
            enemy_position_offset = -30 + car.angle * 1.5

        # Loop through enemy cars
        for index in reversed(range(len(cars) - 1)):
            draw_distance = cars[index].x
            # Create a new variable specifically for enemy car scale to cap its size
            enemy_car_scale = max(0.0001, 1 / (cars[index].x - car.x))

            # Cap the enemy car scale at a maximum value
            enemy_car_scale = min(enemy_car_scale, MAX_ENEMY_CAR_SCALE)

            # Scale the enemy car sprite based on the capped scale
            scaled_enemy_car_sprite = pygame.transform.scale(
                car_sprite2,
                (int(car_sprite2.get_width() * enemy_car_scale), int(car_sprite2.get_height() * enemy_car_scale))
            )

            # Render the enemy car with the capped scale
            render_element(
                screen, scaled_enemy_car_sprite, 100 * enemy_car_scale, 80 * enemy_car_scale, enemy_car_scale,
                cars[index].x, car,
                enemy_position_offset, z_buffer
            )

            # Calculate position of the enemy car for the hitbox
            y = calc_y(cars[index].x) - (-45 + car.angle + 5)
            z = calc_z(cars[index].x) - car.z
            vertical = int(60 + 160 * enemy_car_scale + z * enemy_car_scale)

            if 5 <= vertical < 180:
                horizontal = int(160 - (65 - y) * enemy_car_scale) + car.angle * (vertical - 150)
                enemy_car_rect = scaled_enemy_car_sprite.get_rect(
                    topleft=(2 + horizontal, 60 + vertical - scaled_enemy_car_sprite.get_height() + 1)
                )
            # Update enemy car position
            cars[index].x -= 10 * delta

            # If the enemy car moves out of range, replace it
            if cars[0].x < car.x + 1:
                cars.pop(0)
                cars.append(Car(cars[-1].x + 50))  # Adjust spawn distance as needed

            # Player car rect and mask
            player_car_rect = car_sprite.get_rect(topleft=(120, 180 + math.sin(total_time * car.velocity)))
            player_car_mask = pygame.mask.from_surface(car_sprite)

            # Enemy car mask
            enemy_car_mask = pygame.mask.from_surface(scaled_enemy_car_sprite)

            # Collision detection using masks
            offset = (
                round(1 + enemy_car_rect.left - 1 - player_car_rect.left),
                round(enemy_car_rect.top - player_car_rect.top)
            )
            if player_car_mask.overlap(enemy_car_mask, offset):
                if not collision_occurred:
                    collision_sound.play()
                    collision_occurred = True
                    print("Collision Detected!")
                    # Reset all key variables to default state
                    vertical = 0
                    horizontal = 0
                    z = 0
                    scale = 0
                    draw_distance = 0
                    total_time = 0
                    delta = 0
                    clock = 0
                    # Reset player car properties
                    car.angle = 0
                    car.velocity = 0
                    car.acceleration = 0
                    car.x = 0
                    car.y = 0
                    car.z = 0
                    total_time = 0
                    # Clear all lists or variables representing game elements
                    cars.clear()
                    trees.clear()
                    cars = [Car(-50), Car(-23), Car(7)]
                    trees = [Tree(-67), Tree(-55), Tree(-43), Tree(-33), Tree(-25), Tree(-13), Tree(-3)]
                    music_playing = False
                    time = False
                    start = False
                    screen.blit(car_sprite, (0,0))
                    await main_menu()
                    terrain_mode = "normal"
                    b = 80.0  # Start values for "normal" as float
                    r = 140.0
                    r2 = 17.0
                    g = 8.0
            else:
                collision_occurred = False

        # Render player car
        screen.blit(car_sprite, (120, 180 + math.sin(total_time * car.velocity)))
        pygame.display.flip ()

        if total_time > highscore:
            highscore = total_time

        if abs (car.y - calc_y (car.x + 2) - 95) > 360 and car.velocity > 5:
            # Scale car sprite before rendering
            car.velocity += -car.velocity * delta
            car.acceleration += -car.acceleration * delta
            pygame.draw.circle (screen, (255, 0, 0), (300, 170), 3)
        pygame.display.update ()



async def main():
    state = 'MENU'
    while state != 'QUIT':
        if state == 'MENU':
            state = await main_menu()  # Assuming this function is an async coroutine
        elif state == 'GAME':
            state = await game_loop()  # Calls the newly defined async game loop
        elif state == 'QUIT':
            break  # Exits the while loop when quitting


    pygame.quit()
    exit()

if __name__ == "__main__":
    asyncio.run(main())
